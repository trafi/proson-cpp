// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dto.proto

#ifndef PROTOBUF_dto_2eproto__INCLUDED
#define PROTOBUF_dto_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3002000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3002000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace dto {
class NestedChild;
class NestedChildDefaultTypeInternal;
extern NestedChildDefaultTypeInternal _NestedChild_default_instance_;
class NestedParent;
class NestedParentDefaultTypeInternal;
extern NestedParentDefaultTypeInternal _NestedParent_default_instance_;
class Values;
class ValuesDefaultTypeInternal;
extern ValuesDefaultTypeInternal _Values_default_instance_;
}  // namespace dto

namespace dto {

namespace protobuf_dto_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_dto_2eproto

enum EnumValue {
  None = 0,
  Some = 1,
  Other = 3
};
bool EnumValue_IsValid(int value);
const EnumValue EnumValue_MIN = None;
const EnumValue EnumValue_MAX = Other;
const int EnumValue_ARRAYSIZE = EnumValue_MAX + 1;

const ::google::protobuf::EnumDescriptor* EnumValue_descriptor();
inline const ::std::string& EnumValue_Name(EnumValue value) {
  return ::google::protobuf::internal::NameOfEnum(
    EnumValue_descriptor(), value);
}
inline bool EnumValue_Parse(
    const ::std::string& name, EnumValue* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EnumValue>(
    EnumValue_descriptor(), name, value);
}
// ===================================================================

class Values : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dto.Values) */ {
 public:
  Values();
  virtual ~Values();

  Values(const Values& from);

  inline Values& operator=(const Values& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Values& default_instance();

  static inline const Values* internal_default_instance() {
    return reinterpret_cast<const Values*>(
               &_Values_default_instance_);
  }

  void Swap(Values* other);

  // implements Message ----------------------------------------------

  inline Values* New() const PROTOBUF_FINAL { return New(NULL); }

  Values* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Values& from);
  void MergeFrom(const Values& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Values* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ValString = 14;
  bool has_valstring() const;
  void clear_valstring();
  static const int kValStringFieldNumber = 14;
  const ::std::string& valstring() const;
  void set_valstring(const ::std::string& value);
  #if LANG_CXX11
  void set_valstring(::std::string&& value);
  #endif
  void set_valstring(const char* value);
  void set_valstring(const char* value, size_t size);
  ::std::string* mutable_valstring();
  ::std::string* release_valstring();
  void set_allocated_valstring(::std::string* valstring);

  // required bytes ValBytes = 15;
  bool has_valbytes() const;
  void clear_valbytes();
  static const int kValBytesFieldNumber = 15;
  const ::std::string& valbytes() const;
  void set_valbytes(const ::std::string& value);
  #if LANG_CXX11
  void set_valbytes(::std::string&& value);
  #endif
  void set_valbytes(const char* value);
  void set_valbytes(const void* value, size_t size);
  ::std::string* mutable_valbytes();
  ::std::string* release_valbytes();
  void set_allocated_valbytes(::std::string* valbytes);

  // required double ValDouble = 1;
  bool has_valdouble() const;
  void clear_valdouble();
  static const int kValDoubleFieldNumber = 1;
  double valdouble() const;
  void set_valdouble(double value);

  // required float ValFloat = 2;
  bool has_valfloat() const;
  void clear_valfloat();
  static const int kValFloatFieldNumber = 2;
  float valfloat() const;
  void set_valfloat(float value);

  // required uint32 ValUInt32 = 5;
  bool has_valuint32() const;
  void clear_valuint32();
  static const int kValUInt32FieldNumber = 5;
  ::google::protobuf::uint32 valuint32() const;
  void set_valuint32(::google::protobuf::uint32 value);

  // required int64 ValInt64 = 4;
  bool has_valint64() const;
  void clear_valint64();
  static const int kValInt64FieldNumber = 4;
  ::google::protobuf::int64 valint64() const;
  void set_valint64(::google::protobuf::int64 value);

  // required uint64 ValUInt64 = 6;
  bool has_valuint64() const;
  void clear_valuint64();
  static const int kValUInt64FieldNumber = 6;
  ::google::protobuf::uint64 valuint64() const;
  void set_valuint64(::google::protobuf::uint64 value);

  // required sint64 ValSInt64 = 8;
  bool has_valsint64() const;
  void clear_valsint64();
  static const int kValSInt64FieldNumber = 8;
  ::google::protobuf::int64 valsint64() const;
  void set_valsint64(::google::protobuf::int64 value);

  // required sint32 ValSInt32 = 7;
  bool has_valsint32() const;
  void clear_valsint32();
  static const int kValSInt32FieldNumber = 7;
  ::google::protobuf::int32 valsint32() const;
  void set_valsint32(::google::protobuf::int32 value);

  // required fixed32 ValFixed32 = 9;
  bool has_valfixed32() const;
  void clear_valfixed32();
  static const int kValFixed32FieldNumber = 9;
  ::google::protobuf::uint32 valfixed32() const;
  void set_valfixed32(::google::protobuf::uint32 value);

  // required fixed64 ValFixed64 = 10;
  bool has_valfixed64() const;
  void clear_valfixed64();
  static const int kValFixed64FieldNumber = 10;
  ::google::protobuf::uint64 valfixed64() const;
  void set_valfixed64(::google::protobuf::uint64 value);

  // required sfixed64 ValSFixed64 = 12;
  bool has_valsfixed64() const;
  void clear_valsfixed64();
  static const int kValSFixed64FieldNumber = 12;
  ::google::protobuf::int64 valsfixed64() const;
  void set_valsfixed64(::google::protobuf::int64 value);

  // required sfixed32 ValSFixed32 = 11;
  bool has_valsfixed32() const;
  void clear_valsfixed32();
  static const int kValSFixed32FieldNumber = 11;
  ::google::protobuf::int32 valsfixed32() const;
  void set_valsfixed32(::google::protobuf::int32 value);

  // required bool ValBool = 13;
  bool has_valbool() const;
  void clear_valbool();
  static const int kValBoolFieldNumber = 13;
  bool valbool() const;
  void set_valbool(bool value);

  // required .dto.EnumValue ValEnum = 16;
  bool has_valenum() const;
  void clear_valenum();
  static const int kValEnumFieldNumber = 16;
  ::dto::EnumValue valenum() const;
  void set_valenum(::dto::EnumValue value);

  // required int32 ValInt32 = 3 [default = 42];
  bool has_valint32() const;
  void clear_valint32();
  static const int kValInt32FieldNumber = 3;
  ::google::protobuf::int32 valint32() const;
  void set_valint32(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:dto.Values)
 private:
  void set_has_valdouble();
  void clear_has_valdouble();
  void set_has_valfloat();
  void clear_has_valfloat();
  void set_has_valint32();
  void clear_has_valint32();
  void set_has_valint64();
  void clear_has_valint64();
  void set_has_valuint32();
  void clear_has_valuint32();
  void set_has_valuint64();
  void clear_has_valuint64();
  void set_has_valsint32();
  void clear_has_valsint32();
  void set_has_valsint64();
  void clear_has_valsint64();
  void set_has_valfixed32();
  void clear_has_valfixed32();
  void set_has_valfixed64();
  void clear_has_valfixed64();
  void set_has_valsfixed32();
  void clear_has_valsfixed32();
  void set_has_valsfixed64();
  void clear_has_valsfixed64();
  void set_has_valbool();
  void clear_has_valbool();
  void set_has_valstring();
  void clear_has_valstring();
  void set_has_valbytes();
  void clear_has_valbytes();
  void set_has_valenum();
  void clear_has_valenum();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr valstring_;
  ::google::protobuf::internal::ArenaStringPtr valbytes_;
  double valdouble_;
  float valfloat_;
  ::google::protobuf::uint32 valuint32_;
  ::google::protobuf::int64 valint64_;
  ::google::protobuf::uint64 valuint64_;
  ::google::protobuf::int64 valsint64_;
  ::google::protobuf::int32 valsint32_;
  ::google::protobuf::uint32 valfixed32_;
  ::google::protobuf::uint64 valfixed64_;
  ::google::protobuf::int64 valsfixed64_;
  ::google::protobuf::int32 valsfixed32_;
  bool valbool_;
  int valenum_;
  ::google::protobuf::int32 valint32_;
  friend struct  protobuf_dto_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NestedChild : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dto.NestedChild) */ {
 public:
  NestedChild();
  virtual ~NestedChild();

  NestedChild(const NestedChild& from);

  inline NestedChild& operator=(const NestedChild& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NestedChild& default_instance();

  static inline const NestedChild* internal_default_instance() {
    return reinterpret_cast<const NestedChild*>(
               &_NestedChild_default_instance_);
  }

  void Swap(NestedChild* other);

  // implements Message ----------------------------------------------

  inline NestedChild* New() const PROTOBUF_FINAL { return New(NULL); }

  NestedChild* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NestedChild& from);
  void MergeFrom(const NestedChild& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NestedChild* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // required float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // @@protoc_insertion_point(class_scope:dto.NestedChild)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float x_;
  float y_;
  friend struct  protobuf_dto_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NestedParent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dto.NestedParent) */ {
 public:
  NestedParent();
  virtual ~NestedParent();

  NestedParent(const NestedParent& from);

  inline NestedParent& operator=(const NestedParent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NestedParent& default_instance();

  static inline const NestedParent* internal_default_instance() {
    return reinterpret_cast<const NestedParent*>(
               &_NestedParent_default_instance_);
  }

  void Swap(NestedParent* other);

  // implements Message ----------------------------------------------

  inline NestedParent* New() const PROTOBUF_FINAL { return New(NULL); }

  NestedParent* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NestedParent& from);
  void MergeFrom(const NestedParent& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NestedParent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .dto.NestedChild childs = 3;
  int childs_size() const;
  void clear_childs();
  static const int kChildsFieldNumber = 3;
  const ::dto::NestedChild& childs(int index) const;
  ::dto::NestedChild* mutable_childs(int index);
  ::dto::NestedChild* add_childs();
  ::google::protobuf::RepeatedPtrField< ::dto::NestedChild >*
      mutable_childs();
  const ::google::protobuf::RepeatedPtrField< ::dto::NestedChild >&
      childs() const;

  // optional .dto.NestedChild optional_child = 1;
  bool has_optional_child() const;
  void clear_optional_child();
  static const int kOptionalChildFieldNumber = 1;
  const ::dto::NestedChild& optional_child() const;
  ::dto::NestedChild* mutable_optional_child();
  ::dto::NestedChild* release_optional_child();
  void set_allocated_optional_child(::dto::NestedChild* optional_child);

  // required .dto.NestedChild required_child = 2;
  bool has_required_child() const;
  void clear_required_child();
  static const int kRequiredChildFieldNumber = 2;
  const ::dto::NestedChild& required_child() const;
  ::dto::NestedChild* mutable_required_child();
  ::dto::NestedChild* release_required_child();
  void set_allocated_required_child(::dto::NestedChild* required_child);

  // @@protoc_insertion_point(class_scope:dto.NestedParent)
 private:
  void set_has_optional_child();
  void clear_has_optional_child();
  void set_has_required_child();
  void clear_has_required_child();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::dto::NestedChild > childs_;
  ::dto::NestedChild* optional_child_;
  ::dto::NestedChild* required_child_;
  friend struct  protobuf_dto_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Values

// required double ValDouble = 1;
inline bool Values::has_valdouble() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Values::set_has_valdouble() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Values::clear_has_valdouble() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Values::clear_valdouble() {
  valdouble_ = 0;
  clear_has_valdouble();
}
inline double Values::valdouble() const {
  // @@protoc_insertion_point(field_get:dto.Values.ValDouble)
  return valdouble_;
}
inline void Values::set_valdouble(double value) {
  set_has_valdouble();
  valdouble_ = value;
  // @@protoc_insertion_point(field_set:dto.Values.ValDouble)
}

// required float ValFloat = 2;
inline bool Values::has_valfloat() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Values::set_has_valfloat() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Values::clear_has_valfloat() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Values::clear_valfloat() {
  valfloat_ = 0;
  clear_has_valfloat();
}
inline float Values::valfloat() const {
  // @@protoc_insertion_point(field_get:dto.Values.ValFloat)
  return valfloat_;
}
inline void Values::set_valfloat(float value) {
  set_has_valfloat();
  valfloat_ = value;
  // @@protoc_insertion_point(field_set:dto.Values.ValFloat)
}

// required int32 ValInt32 = 3 [default = 42];
inline bool Values::has_valint32() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Values::set_has_valint32() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Values::clear_has_valint32() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Values::clear_valint32() {
  valint32_ = 42;
  clear_has_valint32();
}
inline ::google::protobuf::int32 Values::valint32() const {
  // @@protoc_insertion_point(field_get:dto.Values.ValInt32)
  return valint32_;
}
inline void Values::set_valint32(::google::protobuf::int32 value) {
  set_has_valint32();
  valint32_ = value;
  // @@protoc_insertion_point(field_set:dto.Values.ValInt32)
}

// required int64 ValInt64 = 4;
inline bool Values::has_valint64() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Values::set_has_valint64() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Values::clear_has_valint64() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Values::clear_valint64() {
  valint64_ = GOOGLE_LONGLONG(0);
  clear_has_valint64();
}
inline ::google::protobuf::int64 Values::valint64() const {
  // @@protoc_insertion_point(field_get:dto.Values.ValInt64)
  return valint64_;
}
inline void Values::set_valint64(::google::protobuf::int64 value) {
  set_has_valint64();
  valint64_ = value;
  // @@protoc_insertion_point(field_set:dto.Values.ValInt64)
}

// required uint32 ValUInt32 = 5;
inline bool Values::has_valuint32() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Values::set_has_valuint32() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Values::clear_has_valuint32() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Values::clear_valuint32() {
  valuint32_ = 0u;
  clear_has_valuint32();
}
inline ::google::protobuf::uint32 Values::valuint32() const {
  // @@protoc_insertion_point(field_get:dto.Values.ValUInt32)
  return valuint32_;
}
inline void Values::set_valuint32(::google::protobuf::uint32 value) {
  set_has_valuint32();
  valuint32_ = value;
  // @@protoc_insertion_point(field_set:dto.Values.ValUInt32)
}

// required uint64 ValUInt64 = 6;
inline bool Values::has_valuint64() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Values::set_has_valuint64() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Values::clear_has_valuint64() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Values::clear_valuint64() {
  valuint64_ = GOOGLE_ULONGLONG(0);
  clear_has_valuint64();
}
inline ::google::protobuf::uint64 Values::valuint64() const {
  // @@protoc_insertion_point(field_get:dto.Values.ValUInt64)
  return valuint64_;
}
inline void Values::set_valuint64(::google::protobuf::uint64 value) {
  set_has_valuint64();
  valuint64_ = value;
  // @@protoc_insertion_point(field_set:dto.Values.ValUInt64)
}

// required sint32 ValSInt32 = 7;
inline bool Values::has_valsint32() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Values::set_has_valsint32() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Values::clear_has_valsint32() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Values::clear_valsint32() {
  valsint32_ = 0;
  clear_has_valsint32();
}
inline ::google::protobuf::int32 Values::valsint32() const {
  // @@protoc_insertion_point(field_get:dto.Values.ValSInt32)
  return valsint32_;
}
inline void Values::set_valsint32(::google::protobuf::int32 value) {
  set_has_valsint32();
  valsint32_ = value;
  // @@protoc_insertion_point(field_set:dto.Values.ValSInt32)
}

// required sint64 ValSInt64 = 8;
inline bool Values::has_valsint64() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Values::set_has_valsint64() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Values::clear_has_valsint64() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Values::clear_valsint64() {
  valsint64_ = GOOGLE_LONGLONG(0);
  clear_has_valsint64();
}
inline ::google::protobuf::int64 Values::valsint64() const {
  // @@protoc_insertion_point(field_get:dto.Values.ValSInt64)
  return valsint64_;
}
inline void Values::set_valsint64(::google::protobuf::int64 value) {
  set_has_valsint64();
  valsint64_ = value;
  // @@protoc_insertion_point(field_set:dto.Values.ValSInt64)
}

// required fixed32 ValFixed32 = 9;
inline bool Values::has_valfixed32() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Values::set_has_valfixed32() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Values::clear_has_valfixed32() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Values::clear_valfixed32() {
  valfixed32_ = 0u;
  clear_has_valfixed32();
}
inline ::google::protobuf::uint32 Values::valfixed32() const {
  // @@protoc_insertion_point(field_get:dto.Values.ValFixed32)
  return valfixed32_;
}
inline void Values::set_valfixed32(::google::protobuf::uint32 value) {
  set_has_valfixed32();
  valfixed32_ = value;
  // @@protoc_insertion_point(field_set:dto.Values.ValFixed32)
}

// required fixed64 ValFixed64 = 10;
inline bool Values::has_valfixed64() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Values::set_has_valfixed64() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Values::clear_has_valfixed64() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Values::clear_valfixed64() {
  valfixed64_ = GOOGLE_ULONGLONG(0);
  clear_has_valfixed64();
}
inline ::google::protobuf::uint64 Values::valfixed64() const {
  // @@protoc_insertion_point(field_get:dto.Values.ValFixed64)
  return valfixed64_;
}
inline void Values::set_valfixed64(::google::protobuf::uint64 value) {
  set_has_valfixed64();
  valfixed64_ = value;
  // @@protoc_insertion_point(field_set:dto.Values.ValFixed64)
}

// required sfixed32 ValSFixed32 = 11;
inline bool Values::has_valsfixed32() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Values::set_has_valsfixed32() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Values::clear_has_valsfixed32() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Values::clear_valsfixed32() {
  valsfixed32_ = 0;
  clear_has_valsfixed32();
}
inline ::google::protobuf::int32 Values::valsfixed32() const {
  // @@protoc_insertion_point(field_get:dto.Values.ValSFixed32)
  return valsfixed32_;
}
inline void Values::set_valsfixed32(::google::protobuf::int32 value) {
  set_has_valsfixed32();
  valsfixed32_ = value;
  // @@protoc_insertion_point(field_set:dto.Values.ValSFixed32)
}

// required sfixed64 ValSFixed64 = 12;
inline bool Values::has_valsfixed64() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Values::set_has_valsfixed64() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Values::clear_has_valsfixed64() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Values::clear_valsfixed64() {
  valsfixed64_ = GOOGLE_LONGLONG(0);
  clear_has_valsfixed64();
}
inline ::google::protobuf::int64 Values::valsfixed64() const {
  // @@protoc_insertion_point(field_get:dto.Values.ValSFixed64)
  return valsfixed64_;
}
inline void Values::set_valsfixed64(::google::protobuf::int64 value) {
  set_has_valsfixed64();
  valsfixed64_ = value;
  // @@protoc_insertion_point(field_set:dto.Values.ValSFixed64)
}

// required bool ValBool = 13;
inline bool Values::has_valbool() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Values::set_has_valbool() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Values::clear_has_valbool() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Values::clear_valbool() {
  valbool_ = false;
  clear_has_valbool();
}
inline bool Values::valbool() const {
  // @@protoc_insertion_point(field_get:dto.Values.ValBool)
  return valbool_;
}
inline void Values::set_valbool(bool value) {
  set_has_valbool();
  valbool_ = value;
  // @@protoc_insertion_point(field_set:dto.Values.ValBool)
}

// required string ValString = 14;
inline bool Values::has_valstring() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Values::set_has_valstring() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Values::clear_has_valstring() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Values::clear_valstring() {
  valstring_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_valstring();
}
inline const ::std::string& Values::valstring() const {
  // @@protoc_insertion_point(field_get:dto.Values.ValString)
  return valstring_.GetNoArena();
}
inline void Values::set_valstring(const ::std::string& value) {
  set_has_valstring();
  valstring_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dto.Values.ValString)
}
#if LANG_CXX11
inline void Values::set_valstring(::std::string&& value) {
  set_has_valstring();
  valstring_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:dto.Values.ValString)
}
#endif
inline void Values::set_valstring(const char* value) {
  set_has_valstring();
  valstring_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dto.Values.ValString)
}
inline void Values::set_valstring(const char* value, size_t size) {
  set_has_valstring();
  valstring_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dto.Values.ValString)
}
inline ::std::string* Values::mutable_valstring() {
  set_has_valstring();
  // @@protoc_insertion_point(field_mutable:dto.Values.ValString)
  return valstring_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Values::release_valstring() {
  // @@protoc_insertion_point(field_release:dto.Values.ValString)
  clear_has_valstring();
  return valstring_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Values::set_allocated_valstring(::std::string* valstring) {
  if (valstring != NULL) {
    set_has_valstring();
  } else {
    clear_has_valstring();
  }
  valstring_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), valstring);
  // @@protoc_insertion_point(field_set_allocated:dto.Values.ValString)
}

// required bytes ValBytes = 15;
inline bool Values::has_valbytes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Values::set_has_valbytes() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Values::clear_has_valbytes() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Values::clear_valbytes() {
  valbytes_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_valbytes();
}
inline const ::std::string& Values::valbytes() const {
  // @@protoc_insertion_point(field_get:dto.Values.ValBytes)
  return valbytes_.GetNoArena();
}
inline void Values::set_valbytes(const ::std::string& value) {
  set_has_valbytes();
  valbytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dto.Values.ValBytes)
}
#if LANG_CXX11
inline void Values::set_valbytes(::std::string&& value) {
  set_has_valbytes();
  valbytes_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:dto.Values.ValBytes)
}
#endif
inline void Values::set_valbytes(const char* value) {
  set_has_valbytes();
  valbytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dto.Values.ValBytes)
}
inline void Values::set_valbytes(const void* value, size_t size) {
  set_has_valbytes();
  valbytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dto.Values.ValBytes)
}
inline ::std::string* Values::mutable_valbytes() {
  set_has_valbytes();
  // @@protoc_insertion_point(field_mutable:dto.Values.ValBytes)
  return valbytes_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Values::release_valbytes() {
  // @@protoc_insertion_point(field_release:dto.Values.ValBytes)
  clear_has_valbytes();
  return valbytes_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Values::set_allocated_valbytes(::std::string* valbytes) {
  if (valbytes != NULL) {
    set_has_valbytes();
  } else {
    clear_has_valbytes();
  }
  valbytes_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), valbytes);
  // @@protoc_insertion_point(field_set_allocated:dto.Values.ValBytes)
}

// required .dto.EnumValue ValEnum = 16;
inline bool Values::has_valenum() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Values::set_has_valenum() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Values::clear_has_valenum() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Values::clear_valenum() {
  valenum_ = 0;
  clear_has_valenum();
}
inline ::dto::EnumValue Values::valenum() const {
  // @@protoc_insertion_point(field_get:dto.Values.ValEnum)
  return static_cast< ::dto::EnumValue >(valenum_);
}
inline void Values::set_valenum(::dto::EnumValue value) {
  assert(::dto::EnumValue_IsValid(value));
  set_has_valenum();
  valenum_ = value;
  // @@protoc_insertion_point(field_set:dto.Values.ValEnum)
}

// -------------------------------------------------------------------

// NestedChild

// required float x = 1;
inline bool NestedChild::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NestedChild::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NestedChild::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NestedChild::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float NestedChild::x() const {
  // @@protoc_insertion_point(field_get:dto.NestedChild.x)
  return x_;
}
inline void NestedChild::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:dto.NestedChild.x)
}

// required float y = 2;
inline bool NestedChild::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NestedChild::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NestedChild::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NestedChild::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float NestedChild::y() const {
  // @@protoc_insertion_point(field_get:dto.NestedChild.y)
  return y_;
}
inline void NestedChild::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:dto.NestedChild.y)
}

// -------------------------------------------------------------------

// NestedParent

// optional .dto.NestedChild optional_child = 1;
inline bool NestedParent::has_optional_child() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NestedParent::set_has_optional_child() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NestedParent::clear_has_optional_child() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NestedParent::clear_optional_child() {
  if (optional_child_ != NULL) optional_child_->::dto::NestedChild::Clear();
  clear_has_optional_child();
}
inline const ::dto::NestedChild& NestedParent::optional_child() const {
  // @@protoc_insertion_point(field_get:dto.NestedParent.optional_child)
  return optional_child_ != NULL ? *optional_child_
                         : *::dto::NestedChild::internal_default_instance();
}
inline ::dto::NestedChild* NestedParent::mutable_optional_child() {
  set_has_optional_child();
  if (optional_child_ == NULL) {
    optional_child_ = new ::dto::NestedChild;
  }
  // @@protoc_insertion_point(field_mutable:dto.NestedParent.optional_child)
  return optional_child_;
}
inline ::dto::NestedChild* NestedParent::release_optional_child() {
  // @@protoc_insertion_point(field_release:dto.NestedParent.optional_child)
  clear_has_optional_child();
  ::dto::NestedChild* temp = optional_child_;
  optional_child_ = NULL;
  return temp;
}
inline void NestedParent::set_allocated_optional_child(::dto::NestedChild* optional_child) {
  delete optional_child_;
  optional_child_ = optional_child;
  if (optional_child) {
    set_has_optional_child();
  } else {
    clear_has_optional_child();
  }
  // @@protoc_insertion_point(field_set_allocated:dto.NestedParent.optional_child)
}

// required .dto.NestedChild required_child = 2;
inline bool NestedParent::has_required_child() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NestedParent::set_has_required_child() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NestedParent::clear_has_required_child() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NestedParent::clear_required_child() {
  if (required_child_ != NULL) required_child_->::dto::NestedChild::Clear();
  clear_has_required_child();
}
inline const ::dto::NestedChild& NestedParent::required_child() const {
  // @@protoc_insertion_point(field_get:dto.NestedParent.required_child)
  return required_child_ != NULL ? *required_child_
                         : *::dto::NestedChild::internal_default_instance();
}
inline ::dto::NestedChild* NestedParent::mutable_required_child() {
  set_has_required_child();
  if (required_child_ == NULL) {
    required_child_ = new ::dto::NestedChild;
  }
  // @@protoc_insertion_point(field_mutable:dto.NestedParent.required_child)
  return required_child_;
}
inline ::dto::NestedChild* NestedParent::release_required_child() {
  // @@protoc_insertion_point(field_release:dto.NestedParent.required_child)
  clear_has_required_child();
  ::dto::NestedChild* temp = required_child_;
  required_child_ = NULL;
  return temp;
}
inline void NestedParent::set_allocated_required_child(::dto::NestedChild* required_child) {
  delete required_child_;
  required_child_ = required_child;
  if (required_child) {
    set_has_required_child();
  } else {
    clear_has_required_child();
  }
  // @@protoc_insertion_point(field_set_allocated:dto.NestedParent.required_child)
}

// repeated .dto.NestedChild childs = 3;
inline int NestedParent::childs_size() const {
  return childs_.size();
}
inline void NestedParent::clear_childs() {
  childs_.Clear();
}
inline const ::dto::NestedChild& NestedParent::childs(int index) const {
  // @@protoc_insertion_point(field_get:dto.NestedParent.childs)
  return childs_.Get(index);
}
inline ::dto::NestedChild* NestedParent::mutable_childs(int index) {
  // @@protoc_insertion_point(field_mutable:dto.NestedParent.childs)
  return childs_.Mutable(index);
}
inline ::dto::NestedChild* NestedParent::add_childs() {
  // @@protoc_insertion_point(field_add:dto.NestedParent.childs)
  return childs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::dto::NestedChild >*
NestedParent::mutable_childs() {
  // @@protoc_insertion_point(field_mutable_list:dto.NestedParent.childs)
  return &childs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::dto::NestedChild >&
NestedParent::childs() const {
  // @@protoc_insertion_point(field_list:dto.NestedParent.childs)
  return childs_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace dto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::dto::EnumValue> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dto::EnumValue>() {
  return ::dto::EnumValue_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_dto_2eproto__INCLUDED
